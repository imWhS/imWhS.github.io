# 네트워크 개론

## 컴퓨터 네트워크

**컴퓨터 네트워크**는 2대 이상의 컴퓨터들이 서로 연결되어 있어서, 컴퓨터들이 서로 데이터를 주고 받을 수 있는 네트워크를 의미합니다.

연결된 컴퓨터들의 규모에 따라 아래와 같이 2가지로 분류할 수 있습니다.

- **LAN(Local Area Network)** : 특정 건물 내부와 같이 지리적으로 제한된 곳에 존재하는 컴퓨터들만 2대 이상 연결되어 있는 네트워크
- **WAN(Wide Area Network)** : 넓은 범위에 구축된 네트워크로, LAN과 LAN이 서로 연결된 것으로도 볼 수 있다.

WAN의 경우, 개인이 넓은 범위로 네트워크를 구축하는 건 불가능에 가까워서 유료로 기업의 도움을 받아야 합니다. 

특히 KT와 같은 ISP에서 유료로 제공하는 서비스 중, 흔히 우리가 알고 있는 **인터넷** 또한 네트워크의 한 종류로서 WAN에 포함되는 개념입니다. 인터넷은 전 세계의 크고 작은 모든 네트워크가 연결된, 거대한 네트워크입니다. 가장 인기 많은 네트워크이기도 합니다.

물리적 거리 차이로 인해 보통 WAN이 LAN보다 전송 속도가 느리고 오류가 많은 편입니다.

## 패킷

**패킷**은 네트워크를 통해 전송되는 데이터의 작은 조각 단위입니다.

인터넷과 같은 네트워크에서 컴퓨터 간 데이터를 주고 받기 위해 따라야 하는 특정한 규칙으로서, 네트워크를 이용해 다른 컴퓨터로 데이터를 보내려면 패킷 단위로 나누어야만 합니다. 

패킷을 사용해야 하는 중요한 이유 중 하나는 네트워크 상에서의 **대역폭**이 제한되기 때문입니다. 우선 대역폭의 개념은 아래와 같습니다.

- **대역폭** : 네트워크에서 이용 가능한 최대 전송 속도로 정보를 전달할 수 있는 '단위 시간 당 전송량'

대역폭은 특정 컴퓨터의 데이터가 독점하는 것을 방지하는 역할을 합니다. 이 대역폭이 수용할 수 있는 범위에 한계가 있기 때문인데요, 이런 상황에서 특정 컴퓨터의 데이터가 대역폭을 많이 차지하면 다른 패킷의 이동을 막을 수 있습니다.

데이터가 목적지 컴퓨터로 도착해도, 패킷으로 전송되었기 때문에 네트워크 상태에 따라 특정 패킷이 원래 보낸(패킷으로 나눈) 순서와 맞지 않게 늦게 도착하거나 누락될 수 있습니다. 즉 비정상적으로 도착할 가능성이 있는 겁니다. 그래서 데이터를 보내기 직전에 패킷마다 순서대로 번호를 붙여 원래 데이터로 복구할 수 있도록 처리해야 합니다.

## 일반 가정에서의 네트워크 구성

일반 가정은 ~~웬만한 부자가 아닌 이상~~ 좁은 범위에 해당하기에 대부분 LAN으로 네트워크를 구성합니다. 

하지만, 요즘 세상에 집 내부 컴퓨터끼리 네트워크를 구성해서 할 수 있는 게 뭐가 없습니다. 멀리 있는 친구랑 게임도 한 판 해야 하지 않을까요? 그래서 다른 지역(가정 외부)의 LAN과도 연결되어야 하기에 WAN의 필요성이 생깁니다. 가장 인기 있는 WAN은 당연히 위에서 말한 인터넷일겁니다. 그리고 인터넷을 사용하기 위해서는 ~~기사님을 불러~~ ISP의 도움을 받아야 합니다.

인터넷 어디 회사 쓰시나요? 한국에는 KT, SK, U plus 등의 ISP 회사에서 인터넷 서비스를 제공하고 속도가 다른 여러 요금제 상품이 있습니다. 이렇게 인터넷을 사용하기 위해서는 ISP, (ISP에서 제공하는) 인터넷 회선을 결정해야 합니다.

ISP가 제공하는 인터넷(다른 지역의 LAN들)은 가정 내의 인터넷 공유기를 통해 수신됩니다. 

- **인터넷 공유기(Broadband router)** : 가정용 라우터로서 인터넷 접속을 위해 사용하는 장비로, 가정 내 컴퓨터를 포함한 장비들(스마트폰, 프린터 등)을 유/무선 LAN으로 구성한다.

즉, 인터넷 공유기를 통해 ISP와 가정의 네트워크가 연결되는 셈입니다.

## 회사에서의 네트워크 구성

회사의 경우, 네트워크(서버)를 외부에 공개해야 할 필요가 있습니다. 회사의 웹 사이트를 외부에 공개하기 위한 웹 서버, 회사 내부와 외부 사용자 간 이메일을 주고 받기 위한 메일 서버, 이 서버들을 도메인 이름으로 접속할 수 있게 하는 DNS 서버 등이 있기 때문입니다. 이들 또한 **스위치**로 LAN 타입의 네트워크를 구성하는데, 이들을 **DMZ 구역**이라는 외부 공개를 위한 네트워크로 부릅니다.

- **DMZ 구역** : 네트워크 구성 요소 중, 네트워크의 외부(ISP가 제공하는 인터넷), 내부 사이에 위치한 subnet이다. 위치적 요인 때문에 외부 공격자가 내부 네트워크로 침투하는 것을 막는 역할도 한다.

회사에서는 위와 같은 서버를 운영하기 위한 방법으로 **on-premise**, **데이터 센터**, **클라우드** 중 하나를 사용할 수 있습니다.

On-premise 방식으로 운영하는 경우, 일반 가정처럼 ISP가 제공하는 인터넷은 회사의 라우터를 통해 접속할 수 있습니다. 하지만, 일반적으로 회사에서는 하나의 메인 인터넷 회선이 내/외부망 서버로 갈라지고, 각 망 별 서버 마다 다시 여러 단말기로 회선이 분리되는 구조를 가집니다. 

이때, 서버에서 여러 대의 단말기로 네트워크를 형성할 때에는 라우터를 사용하지 않습니다. 서버에서 유선 네트워크인 경우 **스위치**, 서버에서 무선 네트워크인 경우 **무선 인터넷 공유기(무선 AP/무선 라우터)**를 사용해야 합니다.

## OSI, TCP/IP 모델

네트워크는 다양한 곳에 위치한 여러 컴퓨터가 참여할 수 있습니다. 그래서, 네트워크에서는 상호 간의 원활한 통신을 위해 **프로토콜**이라는 규약을 지켜야만 합니다. 편지를 먼 거리에 있는 상대방에게 보내기 위해 편지를 쓸 때, 우체통에 넣을 때, 우체국에서 편지를 처리할 때와 같이 각 과정에는 독립된 여러 규칙이 존재하는 것과 같습니다.

네트워크에서도 비슷합니다. 데이터를 보낼 때부터 목적지까지 도착할 때까지 서로 영향을 주지 않는 특징이 있는데요. 네트워크로 데이터를 송수신하기 위해 송신, 수신 컴퓨터 각자 처리해야 할 일을 몇 개의 계층으로 나누어 순서를 정해 처리합니다. 그리고 이 계층을 통틀어 일컫는 말이 모델입니다.

모델은 아래와 같이 2종류가 있는데, 지금 네트워크 환경에서는 사실상 TCP/IP 모델이 주로 사용됩니다.

- **OSI 모델** : 응용, 표현, 세션, 전송, 네트워크, 데이터 링크, 물리 총 7개 계층으로 구성된다.
- **TCP/IP 모델** : OSI 모델보다 간소화되어 응용, 전송, 인터넷, 네트워크 접속 총 4개 계층으로 구성된다.

모델은 표준 규격이기에 네트워크에 접속하는 기기의 종류, 회사가 서로 달라도 통신을 원활하게 할 수 있습니다.

특히 모델의 각 계층에는 서로 독립적으로 처리한 데이터를 넘겨줄 때의 프로토콜이 있습니다. 편지 쓰는 과정처럼요! 그래서 특정 계층에서 데이터를 처리할 때 다른 계층의 영향을 전혀 받지 않습니다. 한 계층에서 해야 할 처리를 끝내면, 정해진 프로토콜을 통해 다음 단계의 계층에게 처리 결과물을 전달해 나갈 뿐입니다.

## 캡슐화

모델을 따라, 데이터를 송신 컴퓨터의 가장 상위 계층에서 하위 계층으로 전달하면, 네트워크를 통해 데이터가 수신 컴퓨터로 이동하며, 수신 컴퓨터의 가장 하위 계층에서 상위 계층으로 역 처리 과정이 일어남과 함께 데이터 수신이 완료됩니다.

이렇게 송신 컴퓨터에서는 각 계층을 거치며 **캡슐화**가 일어납니다. 초기 데이터에 추가적인 헤더나 트레일러가 달라 붙으면서 자연스럽게 데이터를 감싸게 된다는 의미입니다.

가장 하위 계층에서 네트워크로 데이터를 전송하기 위해선 데이터의 앞, 뒤 부분에 전송을 위해 필요한 정보(헤더, 트레일러)들이 붙여진 상태로 데이터가 전달되어야만 합니다. '데이터를 수신할 컴퓨터'에 대한 정보를 포함해야 하기 때문입니다. 

이 정보는 각 계층별로 나누어서 처리하기 때문에, 헤더와 트레일러는 데이터가 각 계층을 지날 때마다 1개 씩 붙여집니다. 즉, 계층을 하나 거칠 때마다 처리한 결과가 데이터에 추가되는 겁니다.

OSI 모델 기준으로 각 계층 별로 추가되는 데이터, 헤더 정보를 웹 사이트 접속에 비유해 설명하면 아래와 같습니다.

1. 응용 계층

    상대방 컴퓨터로 보낼 데이터가 최초로 생성되는 곳이다. 

    송신 컴퓨터에서 특정 웹 사이트로의 접속을 시도한 시점으로, 웹 사이트 접속 요청 데이터가 생성된다. 

    전송 계층으로 데이터가 전달된다.

2. 전송 계층

    신뢰할 수 있는 네트워크 통신이 이루어지게 하는 헤더를 처리한 후 데이터에 붙인다.

    네트워크 계층으로 데이터가 전달된다.

3. 네트워크 계층

    데이터를 다른 네트워크와 통신하기 위한 헤더를 처리한 후 데이터에 붙인다.

    데이터 링크 계층으로 데이터가 전달된다.

4. 데이터 링크 계층

    물리적 통신 채널을 연결하기 위해 관련 헤더와 트레일러를 데이터에 붙여 캡슐화가 끝난다.

    이후 전기 신호로 변환되어 물리 계층을 통해 상대방 컴퓨터로 전달된다. 

## 역캡슐화

물리 계층을 통해 데이터를 수신받은 송신 컴퓨터는 캡슐화 때와 반대로 헤더(트레일러)와 대응하는 계층에 의해 헤더(트레일러)가 단계 별로 제거됩니다.

최종적으로 송신 컴퓨터의 응용 계층에 전달된 데이터에는 모든 헤더와 트레일러가 제거되어 마치 캡슐이 벗겨진 것처럼 원래의 순수 데이터 그 자체만 존재하게 됩니다.

## 물리 계층

**물리 계층**에서는 아래와 같은 일을 하기 위한 기술을 제공합니다.

1. 컴퓨터와 네트워크 장비 연결
2. 데이터를 전기 신호로 변환

컴퓨터에서 사용하는 디지털 데이터는 0, 1로만 구성된 비트열 형태입니다. 하지만 네트워크에서는 신호 형태로만 존재할 수 있습니다.

그래서 네트워크에서 데이터를 주고 받으려면 반드시 디지털 데이터에서 전기 디지털 신호로, 전기 디지털 신호에서 디지털 데이터로 변환되어야 하는데요. 이를 위해 존재하는 컴퓨터 부품이 **LAN 카드**입니다.

네트워크를 통해 데이터를 흐르게 하는 **전송 매체**는 물리적인 선로로, 유선과 무선으로 존재할 수 있습니다.

- 유선 전송 매체 : 트위스트 페어 케이블, 광 케이블
- 무선 전송 매체 : 라디오파, 마이크로파, 적외선

### 트위스트 페어 케이블

**트위스트 페어 케이블**은 유선 전송 매체로, 8개의 구리 선을 2개 씩 꼬아 만든 4 쌍의 전선이 하나의 케이블로 묶인 것으로, 보통 LAN 케이블이라고 부릅니다.

전선 보호 여부에 따라 아래와 같이 분류됩니다.

- UTP : 실드로 보호되어 있지 않아 노이즈 영향을 많이 받지만 저렴한 케이블
- STP : 각 쌍의 전선이 실드로 보호되어 있지만 비싼 케이블

노이즈 영향을 받으면 전기 신호의 형태가 왜곡되지만 STP가 너무 비싸서 대부분 UTP 케이블을 사용합니다.

UTP 케이블은 전송 품질(규격, 속도)에 따라 Cat3부터 Cat7까지 등급이 나누어지고, 케이블의 끝 부분에는 LAN 포트에 연결할 수 있도록 RJ-45 커넥터가 붙어있습니다.

8개의 구리선을 어떤 순서로 끝과 끝에 연결하냐에 따라 아래와 같이 케이블의 종류를 구분할 수 있습니다.

1. 다이렉트 케이블

    8개의 구리 선에 순서대로 번호를 매겼을 때, 최종적으로 서로 같은 번호의 구리 선이 양쪽 커넥터에 연결된다.

    즉, 송신 쪽 구리 선 번호 1, 2, 3, 6이 수신 쪽 구리 선 번호 1, 2, 3, 6에 순서대로 그대로 대응된다.

2. 크로스 케이블

    8개의 구리 선에 순서대로 번호를 매겼을 때, 송신 쪽 3, 6번 구리 선이 수신 쪽 구리선 번호 1, 2에, 송신 쪽 1, 2번 구리 선이 수신 쪽 3, 6에 대응된다.

만약 케이블의 양 쪽 커넥터가 모두 컴퓨터에 꽂혔을 때, 두 컴퓨터가 서로 같은 구리 선 번호로 데이터를 전송하면 데이터 충돌이 발생할 수 있습니다. 이런 상황을 방지하려면 송신 쪽과 수신 쪽 구리 선 번호가 다르게 연결된 크로스 케이블을 사용해야 합니다.

### 리피터

**리피터**는 노이즈에 의해 일그러진 전기 신호를 복원(파형을 정상으로 만들고), 증폭하는 네트워크 중계 장비입니다. 네트워크 통신할 상대방과의 거리가 먼 경우에 사용하면 유용하지만, 최근에는 다른 네트워크 장비에서도 지원하기 때문에 잘 사용하지 않습니다.

**허브(리피터 허브, 더미 허브)**는 리피터처럼 전기 신호를 복원, 증폭하면서도 2개 이상의 포트가 존재해 여러 단말기를 서로 연결할 수 있도록 하는 네트워크 장비입니다. 즉, 여러 개의 포트에 여러 대의 컴퓨터를 연결해, 연결된 컴퓨터끼리 데이터를 서로 주고 받으며 통신할 수도 있는 리피터로 볼 수 있습니다.

하지만 문제가 있습니다. 허브는 받은 전기 신호를 모든 포트로 보내는 성질을 가지고 있는데요. 그래서 송신 컴퓨터가 수신 컴퓨터 한 대를 지정해 데이터를 보내도, 허브에 연결된 다른 모든 컴퓨터로 불필요한 데이터가 전송되어 비효율적입니다. **충돌(Collision)** 문제가 발생할 수도 있고요. 이 문제를 개선한 장비가 스위치입니다.

## 데이터 링크 계층

**데이터 링크 계층**은 LAN에서 데이터를 주고 받을 때 필요한 계층입니다. 

LAN을 구성하는 네트워크 장비 사이에서 신호를 주고 받을 때 사용될 규칙을 정하기 때문에, LAN 내의 허브와 이 허브에 연결된 컴퓨터가 서로 데이터를 '잘' 주고 받기 위해 필요합니다.

특히 규칙을 통해 지정하지 않았더라도 연결되어 있는 모든 (LAN 내의) 수신 컴퓨터에게 데이터가 전송되는 허브의 문제를 해결할 수 있습니다. 규칙에 의해 데이터에 수신 컴퓨터와 송신 컴퓨터 정보가 포함되기 때문에 가능한 일입니다. 아래 <MAC 주소>에서 자세히 설명됩니다.

### 이더넷

데이터 링크 계층에서 사용되는 규칙은 여러 개 있습니다. 그 중 가장 많이 쓰는 규칙은 **이더넷(Ethernet)**입니다.

허브의 또 다른 문제가 하나 있었습니다. 바로 충돌 발생 가능성이 있다는 겁니다. 하나의 LAN에서 2대 이상의 컴퓨터가 동시에 같은 컴퓨터로 데이터를 전송할 수도 있기 때문입니다.

하지만 이더넷의 CSMA/CD 방법을 이용하면 충돌이 발생하지 않도록 세부적인 규칙이 추가됩니다. 이에 따라 데이터가 동시에 케이블을 지나가지 않도록, 2대 중 한 컴퓨터의 데이터 전송 시점을 늦춤으로써 충돌을 방지합니다.

CSMA/CD를 아래와 같이 CD, MA, CD로 분리해 세부적인 의미와 절차를 간단하게 살펴볼 수 있겠습니다.

- CS (Career Sense) : 송신 컴퓨터가 LAN 케이블에 전기 신호가 흐르고 있는지(LAN 케이블을 사용 중인지) 확인
- MA (Multiple Access) : LAN 케이블에 1개 이상의 전기 신호가 흐르고 있지 않으면(LAN 케이블이 비어있으면) 데이터 전송
- CD (Collision Detection): 데이터 전송 완료 후, LAN 케이블에서의 충돌 발생 여부 확인

즉, CSMA/CD는 데이터 전송 전에 LAN 케이블의 사용 여부를 먼저 확인한 후, 아무도 사용 중이지 않을 경우에만 데이터를 전송하고, 이후에 충돌 발생 여부를 확인하는 방법입니다.

하지만 이 방법 또한 비효율적이어서 지금은 거의 사용하지 않습니다. 요즘은 위에서 언급했었던 스위치를 사용하기 때문입니다.

### MAC 주소

물리 계층의 LAN 카드에 의해 전기 디지털 데이터에서 디지털 신호로 변환되고, 네트워크로 전송된다고 했었습니다. 그리고 이 LAN 카드에는 **MAC 주소**가 부여되는데, 이 주소는 전 세계에서 유일합니다. 즉, 같은 제조사 혹은 모델의 LAN 카드라도 모두 다른 주소가 부여됩니다.

TMI로, MAC 주소는 LAN 카드를 회사가 제조할 때 물리적으로 기판에 새긴다는 의미로 **물리 주소**라고도 합니다.

같은 제조사 혹은 모델의 LAN 카드라도 MAC 주소가 다를 수 있는 이유가 있습니다. MAC 주소는 총 48 비트(6 바이트)라는 어마어마하게 긴 길이를 가지고 있는데요. 이 중 절반은 랜 카드 제조사 번호를, 나머지 절반은 해당 제조사가 붙인 시리얼 번호라는 규칙으로 부여되기 때문입니다.

지구 상의 모든 컴퓨터(LAN 카드)에 부여되는 MAC 주소는 전 세계에서 유일하다고 했었죠? LAN 영역에서는 바로 컴퓨터 별로 독자적인 이 MAC 주소를 이용해 LAN을 구성하는 모든 컴퓨터를 구분합니다.

### 이더넷 헤더 & FSC 트레일러

컴퓨터 별로 유일한 주소를 부여할 수 있게 됐으니 네트워크로 데이터를 보낼 때 수신 컴퓨터를 명확하게 지정할 수도 있을 겁니다. 

데이터 링크 계층에선 네트워크 계층으로부터 전달받은 데이터에 헤더와 트레일러가 붙는 캡슐화가 발생했었습니다. 그 중 데이터 링크 계층에서 붙는 헤더를 **이더넷 헤더**라고 부르는데, 이 이더넷 헤더에 수신 컴퓨터에 대한  MAC 주소가 포함됩니다. 송신 컴퓨터에 대한 정보도 당연히 포함되고요.

정확히, 이더넷 헤더에는 송신 컴퓨터의 LAN 카드에 부여된(출발지) MAC 주소와 수신 컴퓨터의 LAN 카드에 부여된(도착지) MAC 주소 총 12 바이트에, 이더넷 유형을 나타내는 2 바이트를 포함해 총 14 바이트의 정보가 포함됩니다.

트레일러의 경우 **FCS(Frame Check Sequence)**로, 데이터 전송 과정에서의 오류 발생 여부를 확인하는 데에 사용됩니다.

TMI로, 이더넷 유형은 이더넷으로 전송되는 상위 계층의 프로토콜 종류를 16진수 형태의 값으로 저장한 것으로, IPv4, ARP 와 같은 프로토콜 종류를 식별하기 위한 번호로 사용됩니다.

시간이 흘러... 이더넷 헤더, FCS 트레일러로 캡슐화 된 데이터를 전송받은 컴퓨터는 데이터의 목적지 MAC 주소가 자신의 것과 일치하는지 확인합니다. 일치하면, 데이터를 비트열로 변환한 후 수신 컴퓨터의 데이터 링크 계층에서 이더넷 헤더, FCS 트레일러를 분해하는 역캡슐화가 일어납니다.

대상이 아닌 컴퓨터에게 데이터가 전송되면, 해당 컴퓨터가 열어볼 수 없습니다. 자신의 MAC 주소와 다른 데이터를 받으면 알아서 파기하도록 규칙이 정해져있기 때문입니다.

### 스위치

앞서 허브보다 더 낫다고 여러 번 언급했던 **스위치**는 데이터 링크 계층에서 동작하며, 레이어 2 스위치 혹은 스위칭 허브로도 불리는 네트워크 장치입니다.

스위치의 포트에 연결되어 있는 컴퓨터의 MAC 주소와 스위치 포트 번호 쌍을 자체적으로 등록, 저장할 수 있는 기능을 가지고 있는데요. 이게 가능한 이유는 스위치에 연결된 컴퓨터의 MAC 주소와 포트 번호가 MAC 주소 테이블(Bridge table, 브릿지 테이블)이라는 스위치 내 데이터베이스에 저장되기 때문입니다.

스위치에 컴퓨터 A와 B를 포함한 여러 대의 컴퓨터가 연결되어 있다고 가정해보겠습니다. 이때 A가 B에게 데이터를 보내려면 B의 MAC 주소가 필요합니다. A, B는 같은 LAN 영역에 포함되기 때문입니다. 그래서 A는 바로 위에서 소개한 MAC 주소 테이블을 참조해 B가 연결된 스위치의 포트 번호를 찾은 후, 이와 쌍을 이루는 MAC 주소를 확인할 수 있게 되고, 스위치에 연결된 다른 컴퓨터를 제외한 B에게만 데이터를 보낼 수 있게 됩니다.

하지만 스위치의 포트에 컴퓨터를 연결해도, 초기의 MAC 주소 테이블에는 아무 MAC 주소도 저장되어 있지 않습니다. 무조건 컴퓨터가 '한 번은 데이터를 전송'해야 테이블에 등록되기 때문입니다. 

다시 위의 컴퓨터 A와 B의 상황의 처음으로 돌아가면서, 새로 산 스위치에 LAN 케이블을 모두 처음 연결한다고 가정해보겠습니다. A가 수신 컴퓨터인 B의 MAC 주소가 포함된 데이터(프레임)를 전송하면, 해당 시점 기준 MAC 주소 테이블에 등록된 MAC 주소는 단 하나도 없을 겁니다. 즉, 어떤 포트로 보내야 할지도, 어떤 포트로 보내선 안 되는지도 알 수 없는 상황입니다. 그렇기 때문에 자기 자신인 A가 연결된 포트를 제외한 나머지 (MAC 주소 테이블에 MAC 주소가 등록되어 있지 않은) 모든 포트로 데이터를 전송합니다. 이렇게, MAC 주소 테이블에 등록된 MAC 주소가 없어 모든 포트로 데이터를 전송해야 하는 경우에 대해 **플러딩**이라고 부릅니다. 

B가 데이터를 수신하면, MAC 주소 테이블에 B의 MAC 주소가 연결된 포트 번호와 짝지어 저장되기 때문에, 이후에 다시 A가 B에게 데이터를 전송하는 경우에는 A가 보낸 데이터의 이더넷 헤더에 포함된 수신 MAC 주소를 통해 스위치가 B의 포트 번호를 찾아 선택할 수 있게 됩니다. 그리고 오직 B에게만 데이터가 전송됩니다. 이렇게, MAC 주소 테이블에 MAC 주소가 저장되어 있어, 해당 포트로만 데이터를 전송하는 경우에 대해 **MAC 주소 필터링**이라고 부릅니다.

위의 <트위스트 페어 케이블>에서 크로스 케이블은 서로 연결된 컴퓨터가 동시에 데이터를 보내도 충돌이 발생하지 않는다고 했었습니다. 케이블 양 쪽 끝에서 송신과 수신 구리 선이 나누어져 있었기 때문이었습니다. 하지만 두 컴퓨터 사이에 허브를 끼얹으면 말이 달라집니다. 크로스 케이블과 달리 허브 내부에서는 송신, 수신 구리 선이 나누어져 있지 않기 때문입니다. 크로스 케이블 내에서는 충돌을 일으키지 않았더라도, 허브를 경유하는 순간에는 이를 보장할 수 없게 됩니다. 이러한 경우에는 같은 시점에 양 쪽 컴퓨터가 동시에 통신할 수 없게 하고, 그렇기 때문에 한 쪽 컴퓨터의 통신이 끝난 후 반대 쪽 컴퓨터가 통신해야 합니다. 이 기법을 **반이중 통신 방식**이라고 합니다. 영화 속에서의 무전기를 생각하시면 될 것 같습니다.

아, 물론 스위치에서는 해당 없습니다! 스위치 내부에서도 충돌을 일어나지 않는 구조를 가지고 있기 때문에, 두 컴퓨터가 동시에 데이터를 주고 받을 수 있기 때문입니다. 이 기법을 **전이중 통신 방식**이라고 하고요.

반이중 통신 방식은 전이중 통신 방식보다 효율도 좋지 못합니다. 같은 시점에 데이터를 동시에 보낼 수 없다는 건, 한 쪽은 이후 시점에 통신해야 한다는 말이기에 네트워크 지연 현상은 기본입니다. 또한, 두 컴퓨터가 동시에 통신하려고 하는 바람에 허브에서 충돌이 발생하면, 허브의 포트에 연결된 모든 (LAN 범위에 포함된) 컴퓨터에도 영향을 미칩니다. 다른 컴퓨터도 결국 충돌 현상이 없어져야 통신을 시도할 수 있기 때문입니다. 즉, 충돌 도메인이 허브와 연결된 모든 컴퓨터가 되는 겁니다.

충돌이 네트워크에 영향을 미치는 범위인 충돌 도메인 결국 좁아질 수록 네트워크 환경에 좋은데요. 스위치의 경우, 기본적으로 충돌 발생 가능성이 없고, 충돌이 발생한다고 해도 충돌 도메인은 해당 컴퓨터 포트 영역를 벗어나지 않기 때문에 충돌로 인한 네트워크 지연 현상도 줄어듭니다.

## 네트워크 계층

이제 더 넓은 세상과 통신할 차례입니다. 인터넷 없이 살 수는 없잖아요? 데이터 링크 계층은 LAN 범위 내에서의 통신을 책임졌다면, **네트워크 계층**은 LAN과 LAN 사이를 연결해 다른 네트워크의 컴퓨터와 통신할 수 있게 합니다. 즉, 보통 '네트워크 사이의 통신'을 책임지는 계층이라고 합니다.

LAN 범위 내에서 다른 컴퓨터와 통신하기 위해 스위치를 썼었는데요, 보다 더 넓은 세상과 통신하기 위해 네트워크 계층을 통해 다른 네트워크와 통신하려면 **라우터(인터넷 공유기/브로드밴드 라우터)**가 필요합니다.

라우터는 라우팅을 해주는 네트워크 장비인데요(...). LAN 범위 밖에는 정말 많은 네트워크가 있고, 도달하기까지의 거리 또한 아주 멀 겁니다. 그래서 목적지 네트워크까지 어떤 경로로 가야하는지 알아야 하기 때문에 라우팅이 반드시 필요합니다. 그래서, 라우터만 설치하면 인터넷에도 연결할 수 있게 되는 겁니다.

물론 라우터가 있다고 해도, 주소가 없으면 아무 소용 없을 겁니다. 목적지 주소가 있어야 그 곳으로의 경로를 알려줄 수 있겠죠! 그렇다고 해서 MAC 주소를 사용할 수는 없습니다. 데이터를 수신할 컴퓨터가 다른 네트워크 중 어떠한 곳에 속해있는지에 대한 식별 정보가 주소에 포함되어야 하기 때문입니다. 그래서 **IP 주소**를 사용해 어떤 네트워크의 어떤 컴퓨터가 데이터를 수신할 것인지에 대한 정보를 표현합니다.

### IP

데이터 링크 계층의 이더넷처럼, 네트워크 계층에서도 통신하기 위해 필요한 규칙이 있습니다. 바로 **IP(Internet Protocol)**입니다.

이더넷 헤더처럼 네트워크 계층에서도 보내려고 하는 데이터에 IP 헤더를 붙여 캡슐화합니다. 다만, 먼 여정을 떠나야 하는 데이터인 만큼 출발지와 목적지 IP 주소 외에도 헤더 길이, 서비스 유형, 패킷 길이 등 같은 많은 정보를 포함합니다. 데이터를 정확하게 전달되게 하기 위해 필요하기 때문입니다.

데이터 링크 계층에서 이더넷 헤더와 FSC 트레일러에 의해 캡슐화 된 데이터를 프레임이라고 했다면, 네트워크 계층에서는 IP 헤더에 의해 캡슐화 된 데이터를 **IP 패킷**이라는 다른 용어를 사용합니다.

### IP 주소

데이터를 목적지로 전송하기 위해 필요한 주소 체계인데, MAC 주소를 같은 나라끼리 보낼 수 있는 주소 체계에 비유한다면 **IP 주소**는 전 세계에 존재하는 다른 나라에 보낼 수 있는 주소 체계를 의미합니다. 정확하게는 어떠한 대륙에 위치했는지, 그리고 대륙의 어느 나라로 데이터를 보낼 건지를 결정할 수 있는 주소 체계로 비유할 수 있을 것 같습니다.

IP 주소는 기본적으로 ISP로부터 받을 수 있습니다. 즉, KT, SKT, U plus와 같은 통신사와 계약하고, 요금을 지불해야 받을 수 있는 주소입니다. 개인이 넓은 범위의 네트워크에 연결하는 건 비용도 많이 들고 사실상 불가능에 가까워서, 유료로 기업의 도움을 받아야 합니다.

IP 주소는 IPv4, IPv6 버전으로 나누어집니다. IPv4 버전은 총 32-Bit(약 43억) 개의 주소를 표현할 수 있고, IPv6 버전은 총 64-Bit(약 340 간) 개의 주소를 표현할 수 있습니다. 현재 사용 중인 건 IPv4 버전의 주소인데요, 조만간 발급할 수 있는 IPv4 버전의 주소가 바닥날 예정이기에 IPv6 버전의 주소도 슬슬 함께 사용하게 됩니다.

IPv4 버전 기준으로, 공인, 사설 IP 주소가 별개의 주소 범위로 존재합니다. 바로 위에서 언급했듯이 IPv4 버전의 IP 주소는 발급할 수 있는 주소가 얼마 없기 때문에 인터넷에 직접 연결되는 라우터 혹은 컴퓨터와 같이 LAN을 대표하는 장비에는 공인 IP 주소가 ISP에 의해 할당됩니다. 라우터에 연결된 컴퓨터를 포함한 나머지 (인터넷에 연결된) 장비에는 사설 IP 주소가 할당됩니다. 사설 IP 주소는 해당 LAN 관리자가 자유롭게 할당할 수 있습니다. 

LAN 내에서 사설 IP 주소를 할당할 장비가 너무 많거나 귀찮으면(...) 라우터가 제공하는 DHCP(Dynamic Host Configuration Protocol) 기능을 통해 주소를 자동으로 할당할 수도 있습니다.

하나의 IP 주소는 네트워크 ID와 호스트 ID로 구성됩니다. 앞서 IP 주소는 대륙과 대륙 내의 나라 위치를 특정할 수 있다고 했었는데요, 여기에서 네트워크 ID는 수 많은 네트워크 중 어떤 네트워크인지를 나타내기에 대륙에, 호스트 ID는 특정된 네트워크 내에서 어떤 컴퓨터(라우터)인지를 나타내기에 나라에 비유할 수 있겠습니다. 이 두 가지 ID가 합쳐져서 하나의 IP 주소가 완성됩니다.

단, 하나의 LAN 영역 기준으로 컴퓨터에 할당할 수 없는 IP 주소가 2개 있습니다.

먼저 호스트 ID가 0인 IP 주소는 절대 컴퓨터에 할당할 수 없습니다. 해당 IP 주소는 **네트워크 주소** 로 따로 정의되어, 네트워크(인터넷)를 구성하는 일부인 해당 LAN 영역 자체(작은 네트워크)를 대표하는 데에 사용되기 때문입니다. 즉, 해당 LAN을 식별하는 주소인 겁니다.

즉, a.b.c.0인 IP 주소는 a.b.c.1부터 a.b.c.254 범위의 IP 주소를 할당받은컴퓨터들을 대표하는 주소이자, a.b.c. 주소로 시작하는 LAN 영역을 식별하기 위한 주소로 사용됩니다.

그리고 호스트 ID가 255인 IP 주소도 절대 컴퓨터에 할당할 수 없습니다. **브로드캐스트 주소** 로 따로 정의되기 때문인데요. 브로드캐스트 주소는 해당 LAN 영역에 포함되는 모든 컴퓨터에게 한 번에 데이터를 보내기 위해 사용되어야 합니다. 

### 서브넷

IP 주소는 네트워크 규모 혹은 용도에 따라 아래와 같은 5개의 클래스로 나누어집니다. 대규모부터 중형, 소규모의 네트워크에는 차례대로 A부터 C까지의 클래스, 멀티캐스트(Multicast) 용도인 경우 D 클래스, 기타 연구 혹은 특수 용도인 경우 E 클래스로 나누어집니다.

각 클래스를 구분짓는 기준은 IP 주소의 가장 왼쪽 자리에서부터 네트워크 ID로 사용하는 비트의 길이입니다. A 클래스의 경우 왼쪽 자리에서부터 8 비트를 네트워크 ID로 사용합니다. 

그런데, 여기서 A 클래스에 포함되는 네트워크만 해도 약 1677만 개나 될 정도로 하나의 클래스의 네트워크 규모도 만만치 않게 큽니다. 여기에서, 이 네트워크에 포함된 모든 컴퓨터에게 브로드캐스트 주소로 패킷을 보내면 어떻게 될까요? 보내야 할 컴퓨터가 너무 많다 보니 네트워크 지연과 같은 이슈가 발생해 혼잡해질 겁니다. 

그래서 IP 주소를 보다 더 세부적으로 나눠야 할 필요성이 생기는 겁니다. 또한, 세부적으로 더 많은 작은 네트워크를 추가로 만들 수 있기 때문에 부족한 (IPv4 기준) IP 주소도 효율적으로 사용할 수도 있기 때문에 안 쓸 이유가 없습니다.

이렇게, 네트워크를 보다 더 작은 단위로 분할한 작은 네트워크를 **서브넷(Subnet)** 이라고 합니다. 네트워크를 서브넷으로 나누는 것을 **서브넷팅(Subneting)** 이라고 하고요.

앞서 이미 IP 주소는 네트워크 ID와 호스트 ID로 구성되어 이미 네트워크 ID 길이만으로 A부터 E까지의 클래스로 분류된다고 했었습니다. 그런데 서브넷팅은 여기에서 더 작은 네트워크로 분할해야 하기에, (네트워크 ID를 제외한) 남은 호스트 ID 길이의 비트를 다시 나누어야 합니다. 결국 하나의 IP 주소가 네트워크 ID, 서브넷 ID, 호스트 ID로 나누어지게 됩니다. 서브넷 ID가 호스트 ID의 일부를 가져가는 셈입니다.

C 클래스의 경우 가장 왼쪽에서부터 24 비트까지를 네트워크 ID로 사용합니다. 그러면, 서브넷 마스크는 남은 (호스트 ID의) 8 비트를 4비트 씩 나누어서 서브넷 ID와 호스트 ID로 사용하게 됩니다. 이러한 방식으로 나누어지기 때문에, 보다 더 많은 네트워크를 만들 수 있다는 것 또한 알 수 있습니다.

그런데, 이렇게 하나의 IP 주소를 3개로 나누어버리면 전체 네트워크를 구성하는 LAN 영역의 말단 컴퓨터 입장에서는 IP 주소만으로 네트워크 ID, 호스트 ID를 판단하기 어려워집니다. 그래서 서브넷팅 된 네트워크의 주소의 네트워크 ID, 호스트 ID를 보다 쉽게 식별하기 위한 값으로 **서브넷 마스크(Subnet Mask)** 를 사용합니다.

서브넷 마스크 값을 부여하는 기준은 간단합니다. 서브넷 마스크도 IP 주소처럼 총 32비트 2진수로 구성되는데요. 대신, IP 주소를 구성하는 비트 중 말단인 호스트 IP는 0, 나머지는 1이 부여됩니다.

A 클래스의 IP 주소인 경우, 가장 왼쪽에서부터 8 비트가 네트워크 ID이기에, 서브넷 마스크 또한 255.0.0.0이 되어야 합니다. (2진수 11111111은 10진수로 256입니다.) Prefix 표기법으로는 '/8'이 서브넷 마스크 값이 됩니다.

위에서 예를 들었던 C 클래스를 서브넷팅 한 경우도 생각해보겠습니다. 네트워크 ID로 총 24 비트까지를 네트워크 ID로 사용한다고 했었습니다. 그런데, 이후의 4 비트를 서브넷 ID로 ~~호스트 ID 것을 빼앗아~~ 사용한다고 했었는데요. 이렇게 서브넷팅 된 경우에는 말단인 호스트 ID를 제외한 나머지(네트워크 ID, 서브넷 ID) 비트를 네트워크 ID 하나로 취급합니다. 즉, 서브넷 마스크 값 기준으로 기존 24 비트에서 4 비트를 추가한 28 비트가 네트워크 ID로 사용되고, 남은 4 비트는 호스트 ID로 사용됩니다. 그래서 서브넷 마스크는 255.255.255.240이 됩니다.

### 라우터

앞에서 **라우터**는 라우팅을 해주는 역할을 한다고 했었습니다!(...) 라우터는 하나의 LAN 범위에 속한 컴퓨터들이 범위 밖의 컴퓨터들과 소통할 수 있게 해주는 소통 도구이자 범위 밖에서 안으로 향하는 출입구입니다.

그리고 네트워크를 분할하기 위해 필요한 네트워크 장비이기도 합니다. 위에서 설명한 스위치를 다시 가져와보겠습니다. 기본적으로 스위치에 연결된 컴퓨터들끼리 그 영역 내의 LAN이라는 작고 ~~귀여운~~ 네트워크를 구성한다고 했었습니다. 그런데 스위치와 스위치를 연결하면 어떻게 될까요? 즉, n 대의 컴퓨터가 연결된 스위치와 m 대의 컴퓨터가 연결된 스위치를 연결하면, n + m 대의 컴퓨터가 포함된, 더 큰 규모의 네트워크로 확장됩니다. 

즉, 스위치 1대만을 기준으로 LAN이라는 작은 네트워크가 형성되지 않는다는 의미입니다. 가정에서 컴퓨터 10대로 2개의 작은 네트워크를 구성하고 싶어 스위치를 2대 산 후 컴퓨터 5대 씩 2대의 스위치에 나누어 연결해도 결국 컴퓨터 10대는 같은 LAN 범위에 포함되는 겁니다.

기존 LAN 범위를 보다 작은 단위로 나누어, 새로운 네트워크를 형성하려면 라우터를 사용해야 합니다. 앞서 예로 들었던 스위치 2대 각자 LAN 케이블로 하나의 라우터 포트에 연결하면, 라우터를 기준으로 스위치 1대를 기준으로 더 작은 네트워크가 형성됩니다. 라우터는 범위 밖 컴퓨터들이 ~~나만의 작은~~ LAN 영역으로 들어오기 위한 출입구로도 쓰인다고 했었죠? 이렇게 라우터에 2개의 스위치를 연결하면, 출입구 또한 2개가 되고, 이에 따라 LAN 영역 또한 출입구 수에 맞춰 2개로 갈라지는 겁니다!

라우터가 제공하는 출입구를 위한 전용 IP 주소가 있습니다. 이 주소를 **기본 게이트웨이(Gateway)** 라고 별도로 부르는데요. LAN 범위 내의 장비들(스위치에 연결된 장비들)만으로는 절대 다른 네트워크로(범위 밖으로) 나갈 수 없다고 했습니다. 그래서 범위 밖과의 소통 도구인 라우터가 이를 대신 담당하기 위해 기본 게이트웨이라는 별도의 IP 주수를 필요로 합니다. 그리고 LAN 범위 내의 장비들이 다른 네트워크로 데이터를 전송하려면 기본 게이트웨이로 데이터를 전송해 라우터에게 맡겨야 합니다.

범위 밖으로 보낼 데이터를 전달받은 라우터는 범위 밖에 존재하는 많은 네트워크 중에서 목적지 네트워크를 찾고, 최적의 경로로로 데이터를 전송해야 합니다. 이 과정을 **라우팅**이라고 합니다.

스위치에 상대방 MAC 주소를 찾기 위한 MAC 주소 테이블이 있었다면, 라우터에는 다른 네트워크를 향하는 경로 정보가 등록된 라우팅 테이블이 있습니다. 기본적으로 라우터는 이 라우팅 테이블에 등록된 경로 정보를 이용해 목적지 네트워크의 수신 컴퓨터로 데이터를 전송합니다.

라우팅 테이블은 자동 혹은 수동으로 경로 정보를 입력할 수 있는데요. 일일이 관리하고 등록하기 힘든 대규모 네트워크일 경우에는 자동으로, 소규모 네트워크일 경우에는 수동으로 경로 정보를 입력합니다. 자동으로 등록하는 경우, 라우팅 프로토콜을 통해 라우터끼리 서로 경로 정보를 교환할 수 있기 때문에 라우팅 테이블 정보를 자동으로 수정하기에 편리합니다.

## 전송 계층

라우터가 최적의 경로로 다른 네트워크의 목적지로 데이터를 전송해줘도, 올바르게 도착하지 못 할 수도 있습니다. 라우터가 고장나거나, 라우팅 정보가 잘 못될 수도 있고, 네트워크 상태에 따라 패킷이 손상될 수도 있기 때문입니다.

여러 시련을 거쳐 패킷이 목적지에 도착했다고 해도, 수신 컴퓨터가 신뢰할 수 있는 데이터인지 알 필요가 있습니다. 바로 위에서 말했듯이 거친 경로를 따라 오면서 어떤 에러나 패킷의 손실이 발생했을 수도 있기 때문입니다. 

이러한 상황에 대비해 목적지에 신뢰할 수 있는 데이터를 전달하기 위해 존재하는 게 **전송 계층** 입니다. 그래서 전송 계층에서 캡슐화되는 헤더에는 오류를 점검하는 기능이 포함됩니다. 수신 컴퓨터가 이 헤더를 비캡슐화했을 때 오류가 발생한 데이터임을 확인하면 데이터 재전송을 요청하도록 설계되었기 때문입니다.

즉, 전송 계층을 사용해야 하는 첫 번째 이유는 네트워크를 통한 데이터 전송의 신뢰성을 보장하기 위해서입니다. 네트워크 계층까지는 목적지까지 데이터를 전달하는 것에 중점을 뒀다면, 전송 계층은 이 데이터가 ‘잘’ 도착한 건지에 대해 확인합니다.

그런데 컴퓨터를 기준으로 데이터가 잘 도착했는지를 결정하는 것은 오류 검증 뿐만이 아닙니다. 컴퓨터에서 데이터를 전송하기 위해 네트워크를 사용하는 애플리케이션은 보통 2개 이상인데요. 애플리케이션의 종류가 달라도 전송 계층에서는 결국 하나의 통로로 데이터가 다른 네트워크로 이동하고, 수신 컴퓨터 또한 하나의 통로에서 나온 데이터를 받게 될 겁니다. 이때, 하나의 통로에서 나온 데이터가 어떤 애플리케이션을 위해 전달된 건지를 알고, 해당 (필요로 하는) 애플리케이션에게까지 전달되어야 최종적으로 데이터가 ‘잘’ 도착했다고 말할 수 있는 겁니다!

그래서 전송 계층에서는 추가로 전송된 데이터가 수신 컴퓨터의 어떤 애플리케이션을 대상으로 하는지에 대한 식별 기능도 포함되어 있습니다. 즉, 수신 컴퓨터에 도착한 데이터를 마지막으로 어떤 애플리케이션에게 전달해야 하는지에 대한 정보를 포함하는 겁니다.

### TCP, UDP

그런데 무조건 신뢰성만 추구한다고 해서 될 일은 아닙니다. 유튜브 같은 동영상 스트리밍 서비스를 생각해봅시다. 동영상 데이터는 정말 정말 큰 크기를 가지고 있기에, 전송해야 할 패킷 또한 어마어마합니다. 그런데 신뢰성을 추구하기 위해선 (아래에서 다루겠지만) 수신자와 송신자 간의 확인 과정을 거쳐야만 합니다. 예를 들어 동영상의 1초를 원활하게 재생하기 위해 필요한 최소 프레임(장면)은 30개라고 했을 때, 1초마다 약 30번의 확인 과정을 거쳐야 하는 겁니다. 데이터는 올바르게 전송되더라도, 이를 보는 우리는 버벅거리는 동영상을 감상해야 할 판입니다. 사실상 신뢰성 보장 자체가 의미 없어지는 상황입니다.

그래서 전송 계층을 거친다고 해서 반드시 신뢰성만 추구할 필요는 없도록 선택권을 줍니다. 앞서 길게 다룬 신뢰성을 보장받을 필요가 있는 데이터를 전송하는지, 아니면 동영상처럼 신뢰성은 좀 포기하되 빠른 전송을 위한 효율성을 보장받을 필요가 있는 데이터를 전송하는지에 대해서 말입니다. 보통 전자와 같이 신뢰성이 보장되는 통신 방식을 **TCP(Transmission Control Protocol)** 라는 연결형 통신 프로토콜을 선택하고, 효율성을 보장받고 싶다면 **UDP(User Datagram Protocol)** 을 선택해 통신해야 합니다.