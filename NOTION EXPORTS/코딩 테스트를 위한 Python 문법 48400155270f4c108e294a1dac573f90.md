요즘 나동빈 님께서 쓰신 [<이것이 취업을 위한 코딩 테스트다 with Python>](https://github.com/ndb796/python-for-coding-test) 를 다시 읽고 있어요! 

그런데, Python으로 제대로 된 프로젝트를 해 본 적이 없기도 하고, 평소에 다룰 일이 별로 없어서 그런지... 학부 때 기초 프로그래밍 수업에서 Python을 한 번 접했음에도 불구하고 ~~나약한 정신력과 기억력 때문에~~ 종종 까먹는 문법이 있더라구요...😭  

그래서! 책의 뒷 부분에 수록된 Appendix A의 내용 중 일부를 ~~정확힌 제가 알고 기억하고 싶은 것들만~~ 정리, 요약해보았어요!

# Python의 Number 타입 연산 특징

## 나누기 연산자

`/`를 이용해 나누기 연산을 하는 경우, Python에서는 기본적으로 실수형으로 처리한다.

## 몫 연산자

`//`를 이용하면 피연산자를 나눈 결과에서 몫만 반환받을 수 있다.

## 거듭제곱 연산자

`**`를 이용하면 피연산자들의 거듭제곱 값을 반환받을 수 있다. 

```bash
a = 2
b = 3
print(a ** b) //a^b
```

위 코드에서 `a ** b`의 결과는 2를 3 거듭제곱 한 값인 8이다.

# 리스트 타입

기본적으로 리스트는 C의 배열처럼 여러 개의 데이터를 **연속적으로** 담아 처리하기 위해서 사용한다.

단, 리스트의 각 요소는 연결 리스트 자료 구조로 구성되어 있다. 즉, 동적으로 요소를 추가하거나 제거할 수 있기 때문에 C++의 Vector와 유사하다.

## 리스트 생성 및 인덱싱

```python
#리스트 생성 후 5개의 원소와 함께 초기화
a = [1, 2, 3, 4, 5]

#비어있는 리스트 생성
a = list()

#크기가 5이며, 모든 값이 0으로 초기화 된 1차원 리스트 생성
a = [0] * n;
```

리스트는 배열 혹은 Vector처럼 인덱스가 0부터 시작한다.

Python의 경우 특정 원소에 접근할 때, 음수도 인덱스 값으로 사용할 수 있다. -1이라는 인덱스로 리스트에 접근하면, 리스트의 가장 마지막 원소를 반환받는다.

```python
a = [1, 2, 3, 4, 5]

#a의 가장 마지막 원소인 5에 접근 후 출력
print(a[-1])
print(a[5])

#a의 가장 첫 번째 원소인 1에 접근 후 출력
print(a[-5])
print(a[0])
```

슬라이싱 기법을 사용하면 리스트 내에서 연속적으로 위치한 원소들을 한 번에 가져올 수 있다.

인덱스 번호 대신 `시작 인덱스`와 `:`, `끝 인덱스`를 넣어주면 되는데, 끝 인덱스에 해당하는 원소는 포함하지 않음에 유의해야 한다.

```python
a = [1, 2, 3, 4, 5]
print(a[1 : 4]) #2, 3, 4
```

## List Comprehension

List Comprehension(리스트 컴프리헨션)은 조건문과 반복문으로 일정한 규칙을 가지고 있는 원소를 가진 리스트를 간편하게 생성할 수 있게 해주는 초기화 방법이다.

```python
#0부터 9까지의 정수 중 홀수만 리스트의 원소에 포함
arr1 = [i for i in range(10) if i % 2 == 1]

#1부터 9까지의 자연수 중 제곱 값을 포함하는 리스트 생성 및 초기화
arr2 = [i * i for i in range(1, 10)]

arr3 = [1, 2, 3, 4, 5]
arr4 = [2, 4]

#arr3에서 2, 4 값을 가지는 원소만 제거 = arr4와 중복되는 값의 원소만 제거
arr5 = [i for i in arr3 if i not in arr4]
```

### 2차원 리스트 생성 및 초기화

3 * 3과 같은 2차원 리스트를 초기화 할 때, 혹은 특정 크기의 2차원 리스트를 초기화해야 할 때 리스트 컴프리헨션을 사용한다.

```python
n = 3
m = 3

#행 3개, 열 3개인 2차원 리스트 생성 및 모두 0 값인 원소로 초기화 
arr = [[0] * m] for _ in range(n)]
```

아래 코드처럼 m 개의 원소 모두 0으로 초기화 된 리스트를 생성하는 `[0] * m`를 단순히 n 번 반복해선 안 된다. 하나의 객체에 대해 참조만 여러 개 생성되기 때문이다. 

```python
n = 3
m = 3

arr = [[0] * m] * n #[0, 0, 0]이라는 객체에 대한 3개의 참조가 생성되어 버린다.

#아래와 같이 특정 원소에만 접근해 값을 바꾸는 시도를 할 경우, 
#0행부터 n행까지의 모든 1열 원소(인덱스 1에 위치한 원소) 값이 바뀐다.
array[1][1] = 10
```

## 관련 메서드

원소가 N개인 리스트를 기준으로,

- `sort`는 기본적으로 오름차순 정렬하는데, N logN 시간 복잡도가 발생한다.
- `reverse`를 이용하면 리스트 내 원소 순서를 모두 뒤집을 수 있다. 시간 복잡도는 O(N)이다.
- 그 외 특정 인덱스에 대한 원소 삽입, 제거 시 발생하는 시간 복잡도는 O(N)이다. 단, `append`를 이용해 리스트의 마지막에 원소를 삽입하는 경우에는 연결리스트 특성 상 O(1)의 시간 복잡도가 발생한다.

# 문자열 연산

문자열은 `"` 혹은 `'`를 이용해 초기화 할 수 있다.

Python의 문자열은 내부적으로 여러 개의 문자로 구성되기에 리스트에서의 인덱싱, 슬라이싱 모두 가능하다.

## 문자열 연산

- `+` 로 2개 이상의 문자열 변수를 연결해 하나의 문자열로 합칠 수 있다.
- *로 2개 이상의 문자열 변수를 양의 정수(리터럴 혹은 변수)와 곱하면, 해당 값만큼 같은 문자열이 여러 번 생성, 연결된다.
- 리스트에서처럼 `[`, `]` 혹은 `:`를 이용해 인덱싱, 슬라이싱 할 수 있다.

# 튜플 타입

리스트처럼 데이터를 순차적으로 저장하는 자료형이다. 하지만 튜플은 대괄호가 아닌, `(`와 `)`를 이용해 선언할 수 있는 자료형으로, 한 번 선언한 후에는 변경될 수 없다는 게 특징이다. 

일반적으로 각 원소의 성질이 서로 다를 때 주로 사용한다. 예를 들어, 다익스트라 최단 경로 알고리즘에서 사용하는 (비용, 노드 번호)라는 다른 성질들로 구성된 데이터를 튜플로 묶어 관리할 수 있다.

## 리스트와의 차이점

1. 한 번 선언된 원소의 값을 인덱싱 후 변경할 수 없다.
2. 공간 효율적이다.

# 사전 타입

```python
KoreanToEnglishData = dict()
data['사과'] = 'Apple'
data['바나나'] = 'Banana'
data['코코넛'] = 'Coconut'

#출력 시: {'사과': 'Apple', '바나나': 'Banana', '코코넛': 'Coconut'}
print(KoreanToEnglishData)
```

키와 값이라는 한 쌍의 데이터를 원소로 가지는 자료형으로서, a라는 리스트에서 첫 번째 원소를 인덱싱하기 위해 `a[0]` 로 접근했다면, 사전은 `0` 대신 데이터를 구성하는 키를 이용해 접근해 값을 반환할 수 있다는 게 특징이다.

키는 수, 문자열, 튜플 자료형 등의 데이터가 사용될 수 있다.

기본적으로 (키, 값) 쌍으로 구성된 데이터를 처리할 때 리스트보다 훨씬 빠르다. 사전은 해시 테이블을 이용하기 때문에, 데이터 탐색 및 수정에 있어 O(1)에 처리할 수 있다는 장점이 있다.

```python
#특정 원소의 존재 여부 확인
if '사과' in data:
	print("'사과'가 키인 데이터 존재")
```

리스트, 문자열, 튜플과 같이 iterable 자료형이기 때문에 `in`을 사용할 수 있다.

## 관련 함수

```python
KoreanToEnglishData = dict()
data['사과'] = 'Apple'
data['바나나'] = 'Banana'
data['코코넛'] = 'Coconut'

key_list = KoreanToEnglishData.keys()
value_list = KoreanToEnglishData.values()
```

사전을 구성하는 원소들의 키와 값 중 하나만 별도로 뽑은 후, 별도의 리스트에 담을 수 있다.

# 집합 타입

```python
data1 = set([1, 2, 3, 4, 5])
data2 = set([1, 1, 2, 2, 2, 3, 4, 5])
```

리스트 또는 문자열을 이용해 만들 수 있는 non iterable 자료형이다. 또한, 오직 '값'에 해당하는 데이터만 담을 수 있다. 

즉, 순서가 없고 인덱스로 쓰이는 키 또는 리스트와 같은 번호도 없기 때문에 인덱싱이 불가능하다.

사전 자료형처럼 O(1) 만에 특정 원소의 존재 여부를 확인할 수 있다.

사전 이름 그대로 데이터의 중복을 허용하지 않는다. 위 코드에서의 `data1`, `data2`는 실제로 1, 2, 3, 4, 5만 저장된다.

특정 데이터가 이미 등장한 적 있는지에 대한 여부를 확인할 때 유용하다.

## 연산

```python
a = set([1, 2, 3, 4, 5])
b = set([3, 4, 5, 6, 7])

t = a | b #합집합
t = a & b #교집합
t = a - b #차집합
```

## 관련 함수

값을 추가하거나 제거할 때 사용하는 `add`, `remove`는 O(1) 만에 완료될 수 있다.

```python
data = set([1, 2, 3])
data.update([4, 5])
print(data) #{1, 2, 3, 4, 5}
```

여러 개의 원소를 새로 추가하려면 `update`를 이용할 수 있다.

# 데이터 입력 및 출력

## 기본 데이터 입력

기본적으로 `input()`을 이용해 한 줄의 문자열을 데이터로 입력받을 수 있다. 

입력받은 데이터를 정수로 써야하는 경우, `int()`를 이용해 타입 변환을 해주어야 한다.

## 여러 개의 데이터 입력

학생 n 명의 성적을 한 번에 입력받아 저장할 떄와 같이, 여러 개의 데이터를 띄어쓰기로 구분해 입력받아야 하는 경우 `split()`를 이용해 list 타입에 인덱스 별로 저장할 수 있다.

```python
data = input().split()
print(data) #['85', '70', '100']
```

성적의 평균을 구하는 등과 같이 연산이 필요해 입력받은 데이터를 정수로 처리해야 하는 경우에는 리스트의 모든 인덱스 별 원소에 지정한 함수를 적용할 수 있게 해주는 `map()`을 이용해야 한다.

기본적으로 `input()` 은 문자열 타입으로 데이터를 입력받기 때문에, 리스트에도 각 인덱스에 문자열 타입의 원소가 저장되는데, 이 인덱스를 일일이 접근해, 원소의 타입을 바꿔주는 작업을 `map()`을 이용해 한 줄로 끝낼 수 있기 떄문이다.

하지만 `map()`으로 반환받은 값의 타입은 object이기 때문에, 다시 원하는 타입인 list로 변환해주는 작업이 추가로 필요하다.

```python
data = list(map(int, input().split()))
```

한 라인으로 입력받아야 할 데이터가 많지 않은 경우에는 list 타입이 아닌, 여러 개의 변수에 바로 저장할 수도 있다.

```python
a, b = map(int, input().split())
```

## 빠른 데이터 입력

수 많은 데이터가 위와 같이 공백으로 구분되어지지 않고, 한 줄에 하나의 데이터를 연속적으로 입력받는 경우, 입력할 때의 동작 속도가 함께 고려되어야만 한다.

그래서 Python의 `sys` 라이브러리를 사용해 `readline()` 을 호출해 빠르게 데이터를 한 줄씩 입력받아야 한다. 단, 입력이 끝낼 때 입력되는 Enter에 의한 줄 바꿈 기호가 함께 데이터로 입력받아지기 때문에, `rstrip()` 을 함께 호출하여 함께 입력된 줄 바꿈 기호를 제거해주어야 한다.

```python
import sys
data = sys.stdin.readline().rstrip()
```

## 데이터 출력

`print()`를 이용하면 매개 변수로 넘긴 변수나 상수를 한 칸 띄우거나 한 줄 마다 구분해 출력할 수 있게 된다.

```python
a = 1
b = 2
print(a, b) #1 2
print(a) #1
print(b) #2
```

서로 다른 타입의 데이터를 한 줄에 함께 출력해야 하는 경우 타입 변환을 통해 하나로 통일하거나, `,`를 이용해 한 칸 띄어 구분해야 한다.

```python
data = 3
print("data의 값은" + str(data) + "입니다.")
print("data의 값은", data, "입니다.")
```

Python 버전이 3.6 이상인 경우 f-string 문법을 사용해 자료형을 변환하지 않고 한 줄에 다양한 자료형(문자열과 정수 등)을 출력할 수 있다.

```python
data = 4
print(f"data의 값은 {answer} 입니다.")
```

# Python 내장 함수

내장 함수는 `input()` 혹은 `print()` 처럼, `import` 명령어 없이 바로 사용할 수 있다.

`min()`, `max()`는 2개 이상의 데이터가 매개 변수로 넘겨졌을 때 사용할 수 있는 내장 함수로, 여러 데이터 중 가장 작은 값, 큰 값을 가진 데이터를 반환한다.

`eval()`은 문자열로 이루어진 수학 수식을 계산한 결과를 반환하는 내장 함수다.

`sum()`은 iterable 객체가 매개 변수로 넘겨졌을 때 사용할 수 있는 내장 함수로, 객체의 모든 인덱스 별 원소에 대한 합을 반환한다.

```python
result = sum([1, 2, 3])
```

## 정렬

`sorted()`를 이용해 iterable 객체 대상으로 원소들이 오름차순으로 정렬된 iterable 데이터를 반환받을 수 있다.

`reverse` 속성으로 `True` 값을 주어, 내림차순으로 정렬할 수도 있다.

```python
sorted_data = sorted([50, 30, 60, 10, 100])
reverse_sorted_data = sorted([50, 30, 60, 10, 100], reverse = True)
```

만약 리스트의 원소들이 또 다른 리스트 혹은 튜플과 같은 타입인 경우, `key` 속성으로 해당 타입에 대한 원소 내에서 특정한 기준을 세워 정렬을 수행할 수도 있다.

만약, 리스트의 원소가 모두 튜플 타입으로 구성되어 있고, 튜플의 두 번째(1번 인덱스) 값을 기준으로 정렬하려는 경우 아래 코드와 같이 람다식을 사용해 기준을 세워주면 된다.

```python
result = sorted([('컴퓨터 구조', 10), ('운영체제', 50), ('프로그래밍 언어론', 70)], key = lambda x: x[1])
```

# 자주 사용하는 Python 표준 라이브러리

## 순열과 조합

리스트와 같은 iterable 객체를 대상으로 특정 원소 n 개를 선출해 순열과 조합을 계산하려면 `itertools` 라이브러리를 사용해야 한다.

먼저, 순열을 계산하려면 `permutations` 를 이용해 계산된 데이터를 반환받을 수 있다. 그리고 조합은 같은 라이브러리 내의 `combinations`를 이용하면 되는데, 둘 다 반환받은 계산된 데이터에 대해 리스트 등의 원하는 타입으로 변환한 후 사용해야 한다.

```python
from itertools import permutations

data = ['A', 'B', 'C']

#A, B, C 중 3개를 선출한 후 순열 계산
n = 3
p_result = list(permutations(data, n))

#A, B, C 중 2개를 선출한 후 조합 계산
n = 2
c_result = list(combinations(data, n))
```

A, B, C 중 A, B와 같이 다른 원소 뿐 아니라, A, A처럼 같은 원소도 뽑는 중복 순열을 계산하려면 `product()`를 사용해야 한다. 단, n 개를 선출하기 위한 속성 값으로 `repeat`를 사용한다.

중복 조합 또한 `combinations_with_replacement()`

```python
from itertools import permutations

data = ['A', 'B', 'C']

n = 2
p_result = list(product(data, repeat = n))
c_result = list(combinations_with_replacement(data, repeat = n))
```

## Deque (Queue)

일반적으로 Python에서 사용하는 list 타입은 가장 마지막에 위치한 원소를 기준으로 데이터를 추가하거나(`append()`), 제거하는데(`pop()`), 이는 반대로 맨 앞에 데이터를 추가하거나 제거하는 경우 데이터의 개수에 비례하는 시간 복잡도 O(N)을 가진다.

그래서, 여러 개의 데이터 중 맨 앞이나 마지막에 보다 빠르게 데이터를 추가하거나 제거하려면 `collections` 라이브러리에서 Deque 자료 구조인 `deque()`를 사용해야 한다.

단, `deque()`는 자료 구조 상, list 타입처럼 인덱싱이나 슬라이싱은 불가능하다.

또한, Python에선 Deque를 이용해 Stack, Queue 자료 구조를 대신한다.

맨 앞의 데이터를 제거하려면 `popleft()`, 추가하려면 `appendleft()`를 사용하며 마지막에 위치한 데이터를 제거하려면 `pop()`, 추가하려면 `append()`를 사용해야 한다.

deque 타입은 list로 바로 변환할 수 있다.

```python
from collections import deque

data = deque([2, 3, 4])
data.appendleft(1)
data.append(10)
data.popleft(1)
data.pop(10)

print(list(data))
```

## 기타 유용한 함수

`collections` 라이브러리의 `Counter` 를 이용하면 iterable 객체에서 특정 원소의 개수를 반환받을 수 있다.

또한, 원소 별 개수를 사전 타입으로 변환해 구성할 수도 있다. 

```python
from collections import Counter

cnt = Counter(['r', 'r', 'c', 'q', 'c', 'f'])
print(cnt['blue'])
print(dict(cnt))
```

`math` 라이브러리에선 팩토리얼, 제곱근, 최대공약수, pi, 자연 상수 e 등을 계산하는 함수를 제공한다. 

```python
import math

#5의 팩토리얼 계산 결과 값 출력
print(math.factorial(5))

#7의 제곱근 계산 결과 값 출력
print(math.sqrt(7))

#21, 14의 최대공약수 계산 결과 값 출력
print(math.gcd(21, 14))

#pi와 자연 상수 e 출력
print(math.pi)
print(math.e)
```